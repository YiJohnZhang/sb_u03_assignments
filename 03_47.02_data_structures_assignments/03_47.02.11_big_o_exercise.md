# 1. Simplifying Expressions
1. O(n + 10)
O(n)
2. O(100 * n)
O(n)
3. O(25)
O(1)
4. O(n^2 + n^3)
O(n^3)
5. O(n + n + n + n)
O(n)
6. O(1000 * log(n) + n)
O(log(n))
7. O(1000 * n * log(n) + n)
O(n*log(n))
8. O(2^n + n^2)
O(2^n)
9. O(5 + 3 + 1)
O(1)
10. O(n + n^(1/2) + n^2 + n * log(n)^10)
O(n^2)

# 2. Calculate Time Complexity
1. 
```js
function logUpTo(n) {
  for (let i = 1; i <= n; i++) {
    console.log(i);
  }
}

**Time Complexity**: O(n)

2. 
```js
function logAtLeast10(n) {
  for (let i = 1; i <= Math.max(n, 10); i++) {
    console.log(i);
  }
}
```
**Time Complexity**: O(n)
because it can run n times, worst case

3.
```js
function logAtMost10(n) {
  for (let i = 1; i <= Math.min(n, 10); i++) {
    console.log(i);
  }
}
```
**Time Complexity**: O(1)

4.
```js
function onlyElementsAtEvenIndex(array) {
  let newArray = [];
  for (let i = 0; i < array.length; i++) {
    if (i % 2 === 0) {
      newArray.push(array[i]);
    }
  }
  return newArray;
}
```
**Time Complexity**: O(n)
because practically O(n/2)

5.
```js
function subtotals(array) {
  let subtotalArray = [];
  for (let i = 0; i < array.length; i++) {
    let subtotal = 0;
    for (let j = 0; j <= i; j++) {
      subtotal += array[j];
    }
    subtotalArray.push(subtotal);
  }
  return subtotalArray;
}
```
**Time Complexity**: O(n^2)

6.
```js
function vowelCount(str) {
  let vowelCount = {};
  const vowels = "aeiouAEIOU";

  for (let char of str) {
    if(vowels.includes(char)) {
      if(char in vowelCount) {
        vowelCount[char] += 1;
      } else {
        vowelCount[char] = 1;
      }
    }
  }

  return vowelCount;
}
```
**Time Complexity**: O(n)

# 3. Short Answer
1. True or false: n^2 + n is O(n^2).
**True**

2. True or false: n^2 * n is O(n^3).
**True**

3. True or false: n^2 + n is O(n).
**False**

4. What’s the time complexity of the `.indexOf` array method?
EDIT: **O(n)**: loops through the array and find it
-**O(1)** because the object has probably been keyed.-

5. What’s the time complexity of the `.includes` array method?
EDIT: **O(n)**: loop through the array and find it.
-**O(n*log(n))** assuming it is optimized (search method, if something like binary search?).-

6. What’s the time complexity of the `.forEach` array method?
**O(n)** because it goes through each element.

7. What’s the time complexity of the `.sort` array method?
**O(n*log(n))** assuming it is optimized (sort method).

8. What’s the time complexity of the `.unshift` array method?
**O(1)**. because it is just adding an element to the end.

9. What’s the time complexity of the `.push` array method?
**O(1)**. because it is just adding an element to the end.

10. What’s the time complexity of the `.splice` array method?
EDIT: **O(n)**. go through each element and create a new variable when it finds the delimiting string.
-**O(n*log(n))**. because although it does assignment, O(n), it also searches for the splice string.-

11. What’s the time complexity of the `.pop` array method?
**O(1)**. because it is just removing (edit: the last element) and assigning.

12. What’s the time complexity of the Object.keys()` function?
**O(n)**. Because it would go through an iterable object and return each key; however, if it is already stored in metadata: O(1).

BONUS
13. What’s the space complexity of the `Object.keys()` function?
**O(n)**, it is an iterable object.
